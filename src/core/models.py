"""
Core data models for the trading agent
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any

from .enums import SignalType, StrategyType


@dataclass
class MarketData:
    """Market data structure for a single point in time"""
    symbol: str
    price: float
    volume: float
    change_24h: float
    timestamp: datetime
    bid: Optional[float] = None
    ask: Optional[float] = None
    high_24h: Optional[float] = None
    low_24h: Optional[float] = None
    vwap: Optional[float] = None
    chain: str = ""
    
    @property
    def spread(self) -> Optional[float]:
        """Calculate bid-ask spread"""
        if self.bid is not None and self.ask is not None:
            return self.ask - self.bid
        return None
    
    @property
    def spread_percent(self) -> Optional[float]:
        """Calculate bid-ask spread as percentage"""
        if self.spread is not None and self.price > 0:
            return self.spread / self.price
        return None


@dataclass
class TradingSignal:
    """Trading signal generated by strategies"""
    symbol: str
    signal: SignalType
    confidence: float  # 0.0 to 1.0
    strategy: StrategyType
    target_allocation: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    reasoning: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def signal_strength(self) -> float:
        """Get numeric signal strength"""
        return self.signal.value * self.confidence
    
    def is_actionable(self, min_confidence: float = 0.5) -> bool:
        """Check if signal is actionable based on confidence"""
        return (
            self.signal != SignalType.HOLD and 
            self.confidence >= min_confidence
        )


@dataclass
class Position:
    """Portfolio position tracking"""
    symbol: str
    quantity: float
    avg_price: float
    current_price: float
    unrealized_pnl: float
    realized_pnl: float = 0.0
    entry_time: datetime = field(default_factory=datetime.now)
    last_updated: datetime = field(default_factory=datetime.now)
    
    @property
    def market_value(self) -> float:
        """Current market value of position"""
        return self.quantity * self.current_price
    
    @property
    def total_pnl(self) -> float:
        """Total P&L (realized + unrealized)"""
        return self.realized_pnl + self.unrealized_pnl
    
    @property
    def pnl_percent(self) -> float:
        """P&L as percentage of initial investment"""
        if self.avg_price > 0:
            return (self.current_price - self.avg_price) / self.avg_price
        return 0.0
    
    @property
    def cost_basis(self) -> float:
        """Total cost basis of position"""
        return self.quantity * self.avg_price
    
    def update_price(self, new_price: float) -> None:
        """Update current price and recalculate unrealized P&L"""
        self.current_price = new_price
        self.unrealized_pnl = (new_price - self.avg_price) * self.quantity
        self.last_updated = datetime.now()
    
    def add_to_position(self, quantity: float, price: float) -> None:
        """Add to existing position (updates average price)"""
        if quantity <= 0:
            return
        
        total_cost = self.cost_basis + (quantity * price)
        total_quantity = self.quantity + quantity
        
        self.avg_price = total_cost / total_quantity
        self.quantity = total_quantity
        self.update_price(self.current_price)
    
    def reduce_position(self, quantity: float, price: float) -> float:
        """Reduce position and return realized P&L"""
        if quantity <= 0 or quantity > self.quantity:
            return 0.0
        
        # Calculate realized P&L for the portion being sold
        realized_pnl = (price - self.avg_price) * quantity
        self.realized_pnl += realized_pnl
        
        # Update quantity
        self.quantity -= quantity
        
        # Update unrealized P&L
        self.update_price(self.current_price)
        
        return realized_pnl


@dataclass
class Portfolio:
    """Portfolio management and tracking"""
    cash: float
    positions: Dict[str, Position] = field(default_factory=dict)
    total_value: float = 0.0
    target_allocations: Dict[str, float] = field(default_factory=dict)
    last_updated: datetime = field(default_factory=datetime.now)
    
    def update_total_value(self) -> None:
        """Update total portfolio value"""
        position_value = sum(pos.market_value for pos in self.positions.values())
        self.total_value = self.cash + position_value
        self.last_updated = datetime.now()
    
    def get_allocation(self, symbol: str) -> float:
        """Get current allocation percentage for symbol"""
        if self.total_value <= 0:
            return 0.0
        
        if symbol == "USDC" or symbol == "cash":
            return self.cash / self.total_value
        
        position = self.positions.get(symbol)
        if not position:
            return 0.0
        
        return position.market_value / self.total_value
    
    def get_target_allocation(self, symbol: str) -> float:
        """Get target allocation for symbol"""
        return self.target_allocations.get(symbol, 0.0)
    
    def get_allocation_drift(self, symbol: str) -> float:
        """Get allocation drift from target"""
        current = self.get_allocation(symbol)
        target = self.get_target_allocation(symbol)
        return current - target
    
    def needs_rebalancing(self, threshold: float = 0.05) -> bool:
        """Check if portfolio needs rebalancing"""
        for symbol in self.target_allocations:
            if abs(self.get_allocation_drift(symbol)) > threshold:
                return True
        return False
    
    def get_total_pnl(self) -> float:
        """Get total portfolio P&L"""
        return sum(pos.total_pnl for pos in self.positions.values())
    
    def get_unrealized_pnl(self) -> float:
        """Get total unrealized P&L"""
        return sum(pos.unrealized_pnl for pos in self.positions.values())
    
    def get_realized_pnl(self) -> float:
        """Get total realized P&L"""
        return sum(pos.realized_pnl for pos in self.positions.values())
    
    def add_position(self, symbol: str, quantity: float, price: float) -> None:
        """Add or update position"""
        if symbol in self.positions:
            self.positions[symbol].add_to_position(quantity, price)
        else:
            self.positions[symbol] = Position(
                symbol=symbol,
                quantity=quantity,
                avg_price=price,
                current_price=price,
                unrealized_pnl=0.0
            )
        self.update_total_value()
    
    def reduce_position(self, symbol: str, quantity: float, price: float) -> float:
        """Reduce position and return realized P&L"""
        if symbol not in self.positions:
            return 0.0
        
        realized_pnl = self.positions[symbol].reduce_position(quantity, price)
        
        # Remove position if quantity is zero
        if self.positions[symbol].quantity <= 0:
            del self.positions[symbol]
        
        self.update_total_value()
        return realized_pnl
    
    def update_prices(self, prices: Dict[str, float]) -> None:
        """Update all position prices"""
        for symbol, price in prices.items():
            if symbol in self.positions:
                self.positions[symbol].update_price(price)
        self.update_total_value()


@dataclass
class TradeOrder:
    """Trade order structure"""
    from_token: str
    to_token: str
    amount: float
    order_type: str = "market"
    timestamp: datetime = field(default_factory=datetime.now)
    expected_output: Optional[float] = None
    slippage: Optional[float] = None
    max_slippage: float = 0.02
    
    @property
    def is_buy_order(self) -> bool:
        """Check if this is a buy order (from USDC to token)"""
        return self.from_token in ["USDC", "USD", "cash"]
    
    @property
    def is_sell_order(self) -> bool:
        """Check if this is a sell order (from token to USDC)"""
        return self.to_token in ["USDC", "USD", "cash"]
    
    def validate(self) -> bool:
        """Validate order parameters"""
        if self.amount <= 0:
            return False
        
        if self.from_token == self.to_token:
            return False
        
        if self.slippage and self.slippage > self.max_slippage:
            return False
        
        return True


@dataclass
class TradeResult:
    """Trade execution result"""
    order: TradeOrder
    success: bool
    executed_amount: Optional[float] = None
    executed_price: Optional[float] = None
    actual_output: Optional[float] = None
    actual_slippage: Optional[float] = None
    fee: Optional[float] = None
    transaction_id: Optional[str] = None
    error_message: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    @property
    def effective_price(self) -> Optional[float]:
        """Calculate effective price of the trade"""
        if self.executed_amount and self.actual_output:
            return self.actual_output / self.executed_amount
        return None


@dataclass
class PerformanceMetrics:
    """Portfolio performance metrics"""
    total_return: float
    annualized_return: float
    volatility: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    profit_factor: float
    total_trades: int
    winning_trades: int
    losing_trades: int
    avg_win: float
    avg_loss: float
    current_value: float
    initial_value: float
    timestamp: datetime = field(default_factory=datetime.now)
    
    @property
    def risk_adjusted_return(self) -> float:
        """Risk-adjusted return (return per unit of volatility)"""
        return self.total_return / self.volatility if self.volatility > 0 else 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            "total_return": self.total_return,
            "annualized_return": self.annualized_return,
            "volatility": self.volatility,
            "sharpe_ratio": self.sharpe_ratio,
            "max_drawdown": self.max_drawdown,
            "win_rate": self.win_rate,
            "profit_factor": self.profit_factor,
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "avg_win": self.avg_win,
            "avg_loss": self.avg_loss,
            "current_value": self.current_value,
            "initial_value": self.initial_value,
            "risk_adjusted_return": self.risk_adjusted_return,
            "timestamp": self.timestamp.isoformat()
        }